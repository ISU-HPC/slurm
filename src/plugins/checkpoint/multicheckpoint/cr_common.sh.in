
###########################################
###########################################
####  DECISION OF CHECKPOINT LIBRARY ######

##TODO Manuel: OJOOOO esto hay que mejorarlo. Pensar cómo hacer que llame a BLCR sólo si hemos compilado el código con BLCR
#TODO a parte hay que meter algún tipo de inteligencia aquí
#decides which checkpoint library to use
#return: Name of the checkpoint library to use (DMTCP, BLCR or CRIU).
whichCheckpointLib(){

  #BLCR
  BLCR=true
  type cr_run >/dev/null 2>&1 || BLCR=false

  #DMTCP
  DMTCP=true
  type dmtcp_launch >/dev/null 2>&1 || DMTCP=false

  #CRIU
  CRIU=true
  type criu >/dev/null 2>&1 || CRIU=false

  if [ "$BLCR" == true ]
  then
    checkpointLib="BLCR"
  elif [ "$DMTCP" == true ]
  then
    checkpointLib="DMTCP"
  elif [ "$CRIU" == true ]
  then
    checkpointLib="CRIU"
  fi
  return 0
}

#################################
#################################
####  CONCURRENCY CONTROL #######

#this makes sure that only a task (in case of multitask jobs) executes this script
#$1: folder  where concurrence files will be stored. For convenience, here I will store checkpoint files too
#returns: 0 if this was the first task, 1 if not
semaphore(){
  checkpoint_folder=$1
  mkdir -p $checkpoint_folder
  cd $checkpoint_folder

  firstTask=1

  lockdir=$checkpoint_folder"/$SLURM_JOB_ID.mutprueba.lock"

  if mkdir "$lockdir"  &> /dev/null
  then
    checkpoint_library="$checkpoint_folder/checkpoint_library"

    #if this is the first node, start coordinator
    if [ ! -f $checkpoint_library ]; then
      touch $checkpoint_library
      firstTask=0
     fi

     # remove directory when script finishes
     rm -rf "$checkpoint_folder"
  fi
  cd -  2>&1 >/dev/null  #this is for silent CD
  return $firstTask
}
